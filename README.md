# 智能笔记管理器（note-ai-manager）

一个基于 FastAPI + 原生前端的本地可用「智能笔记」应用：

- AI 自动分析笔记内容并提取「分类、标签」（仅分析前500字符）
- 一键 AI 优化正文并生成标题（默认不修改内容，仅提取标题、分类、标签）
- 笔记保存到 SQLite 与本地 Markdown 文件，支持全文搜索
- 词云展示热门分类与标签，点击可筛选
- 前后端本地运行，默认无需外网（可接入兼容 OpenAI 的本地/远程模型）


## 功能特性

- 自动分类与标签：调用兼容 OpenAI 的 API，根据正文前500字符智能归类并打标签
- 分析标题分类功能：自动提取标题、分类、标签，不修改原文内容
- AI优化重写功能：根据用户输入的提示词优化内容，需要用户提供具体的优化要求
- 全文检索与条件过滤：支持搜索、按分类/标签过滤
- 全屏编辑模式：支持全屏显示笔记，提供更大的编辑空间和更好的阅读体验
- 本地持久化：SQLite 数据库 + `notes/分类/标题.md` 文件
- 纯前端页面：无需构建，打开即可用
- 智能请求管理：AI优化重写请求超时时间延长至2分钟，防重复点击，优化用户体验


## 目录结构

```text
note-ai-manager/
  ├─ backend/               # 后端代码目录
  │  ├─ app/               # FastAPI 应用
  │  │  ├─ main.py         # 应用入口
  │  │  ├─ api/            # API 路由
  │  │  ├─ services/       # 业务逻辑服务
  │  │  ├─ models/         # 数据模型
  │  │  └─ config/         # 配置文件
  │  └─ requirements.txt   # 后端依赖
  ├─ frontend/             # 前端代码目录
  │  └─ js/                # JavaScript 模块目录
  │     ├─ core/           # 核心模块
  │     ├─ components/     # UI 组件
  │     ├─ services/       # 服务模块
  │     ├─ utils/          # 工具函数
  │     └─ models/         # 数据模型
  ├─ index.html            # 主页面
  ├─ frontend/
  │  └─ styles.css         # 样式文件
  ├─ src/input.css         # Tailwind CSS 源文件
  ├─ package.json          # Node.js 依赖
  ├─ tailwind.config.js    # Tailwind 配置
  ├─ data/notes.db         # SQLite 数据库
  └─ notes/                # Markdown 文件按分类分目录存放
```


## 环境要求

- Python 3.10 或更高版本
- Node.js 16 或更高版本（用于构建 Tailwind CSS）
- 可访问一个兼容 OpenAI 的推理服务（任选其一）：
  - 公有云：`https://api.openai.com/v1`（需要有效 Key）
  - 本地/私有：例如 Ollama、OpenAI 兼容网关，提供 `base_url` 与 `api_key`


## 快速开始

### 方法一：一键安装（推荐）
```bash
# Windows 用户
setup.bat

# Linux/Mac 用户
chmod +x setup.sh
./setup.sh
```

### 方法二：手动安装
```bash
# 1) 安装 Python 依赖
pip install -r requirements.txt

# 2) 安装 Node.js 依赖
npm install

# 3) 构建 Tailwind CSS
npm run build-css-prod

# 4) 启动服务（默认 http://127.0.0.1:8000）
python -m uvicorn backend.app.main:app --host 0.0.0.0 --port 8000 --reload
```

打开浏览器访问 `http://127.0.0.1:8000`。


## 前端使用说明

### 模块化架构
前端已重构为模块化架构，主要特点：
- **分离关注点**：HTML、CSS、JavaScript 完全分离
- **组件化设计**：可复用的 UI 组件（模态框、分页、词云等）
- **模块化 JS**：按功能拆分为独立模块，便于维护和扩展
- **响应式设计**：支持移动端和桌面端
- **Tailwind CSS**：使用本地构建的 Tailwind CSS，避免 CDN 警告

### Tailwind CSS 构建说明
项目已从 CDN 版本的 Tailwind CSS 迁移到本地构建版本：

- **开发模式**：`npm run build-css` - 监听文件变化并自动重新构建
- **生产模式**：`npm run build-css-prod` - 构建压缩版本
- **配置文件**：`tailwind.config.js` - 自定义 Tailwind 配置
- **源文件**：`src/input.css` - 包含所有自定义样式和组件
- **输出文件**：`frontend/styles.css` - 最终生成的样式文件

如需修改样式：
1. 编辑 `src/input.css` 文件
2. 运行 `npm run build-css-prod` 重新构建
3. 刷新浏览器查看效果

### 文件说明
- `index.html`：主页面，包含所有 HTML 结构
- `frontend/styles.css`：所有样式定义，包括组件样式和工具类
- `frontend/js/core/app.js`：主应用模块，协调各个模块
- `frontend/js/services/api.js`：API 接口封装，包含错误处理
- `frontend/js/components/`：可复用组件（模态框、分页、词云等）
- `frontend/js/utils/`：工具函数和常量定义

### 使用步骤
1. 首次进入，先在页面顶部的「API 配置」中填写：
   - API 地址（Base URL），例如：`https://api.openai.com/v1` 或你的本地服务地址
   - API Key
   - 默认模型（如 `qwen3:30b-a3b-46k`，可根据你的服务可用模型填写）
2. 登录成功后即可：
   - 新建笔记：输入正文，必要时点击「AI 优化」获取更优表达与标题，然后保存
   - 搜索与筛选：顶部搜索框，右侧词云点击可按分类或标签过滤
   - 预览/优化/更新：点击列表项打开预览，支持再次 AI 优化后保存更新
   - 全屏编辑：在预览弹窗中点击全屏按钮，进入全屏编辑模式，提供更大的编辑空间
   - 删除笔记：在预览弹窗中删除


## 后端 API 文档（简要）

> 基础地址：`/api`

- POST `/login`：保存 `api_url`、`api_key`、`model` 到 Cookie 并校验连通
  - 请求体：`{ api_url: string, api_key: string, model?: string }`
  - 响应：`{ message: "登录成功" }`

- POST `/logout`：清理会话与 Cookie
  - 响应：`{ message: "已退出登录" }`

- GET `/config`：读取当前 Cookie 配置
  - 响应：`{ api_url, api_key, logged_in, default_model }`

- POST `/note`：新建笔记（自动提取分类/标签、写入 DB 与 Markdown 文件；也可在请求体中直接指定）
  - 请求体：`{ title: string, content: string, category?: string, tags?: string }`
  - 响应：`{ message: "笔记保存成功", filename }`

- PUT `/note`：更新笔记内容/标题/分类/标签（未显式提供的字段将保留或由 AI 重新推断）
  - 请求体：`{ id: number, title?: string, content?: string, category?: string, tags?: string }`
  - 响应：`{ message: "更新成功", id }`

- DELETE `/note?id=ID`：删除笔记（数据库记录与对应文件）
  - 响应：`{ message: "已删除", id }`

- GET `/note?id=ID`：获取单条笔记详情
  - 响应：`{ id, title, content, category, tags, filename, created_at }`

- GET `/notes`：按时间倒序列出所有笔记
  - 响应：`Array<NoteMeta>`

- GET `/notes/by_category?category=名称`：按分类列出

- GET `/notes/by_tag?tag=名称`：按标签精确匹配列出

- GET `/search?query=关键词`：全文搜索（标题/内容/分类/标签）

- POST `/optimize`：AI 优化正文并生成标题，同时自动抽取分类与标签
  - 请求体：`{ content: string, prompt?: string }`
  - 响应：`{ title: string, optimized: string, category: string, tags: string[] }`
  - 说明：
    - 无提示词（prompt为空）：仅分析前4000字符，提取标题、分类、标签，不修改原文内容
    - 有提示词：根据用户提示词优化内容，分析前20000字符，只更新文本内容

- GET `/categories`：返回已有分类（去重、按频次倒序）
- GET `/tags`：返回已有标签（去重、按频次倒序）


## 数据与存储

- SQLite：文件位于 `data/notes.db`（首次运行自动创建与建表）
  - 表 `notes` 字段：`id, title, content, category, tags, filename, created_at`
- Markdown 文件：保存在 `notes/分类/标题.md`
  - 文件内容：一级标题为标题，首部包含「分类、标签」信息，其后为正文
  - 更新笔记时如分类或标题变化，会自动删除旧文件并写入新路径

### AI 功能说明

#### 分析标题分类功能
- **功能**：自动提取标题、分类、标签，不修改原文内容
- **触发方式**：点击绿色的"分析标题分类"按钮
- **内容分析**：仅分析笔记内容的前4000个字符
- **适用场景**：快速获取笔记的元数据信息，保持原文完整性
- **无需输入**：不需要用户提供任何提示词

#### AI优化重写功能
- **功能**：根据用户输入的提示词优化内容
- **触发方式**：点击紫色的"AI优化重写"按钮
- **内容分析**：分析前20000个字符，提供更全面的优化
- **适用场景**：需要AI帮助改进文章表达和结构
- **必须输入**：需要用户在上方输入框中填写具体的优化要求

#### 使用建议
- 首次创建笔记时，建议先使用"分析标题分类"获取标题、分类、标签
- 需要改进内容表达时，使用"AI优化重写"并输入具体的优化要求
- 两个功能可以配合使用，先分析再优化


## 模型与连接说明

后端通过 `openai` SDK 以「兼容 OpenAI」的方式连接任意推理服务：

- Base URL：在前端登录处填写（例如 `http://localhost:11434/v1`）
- API Key：对应服务的密钥（本地服务如允许可填任意占位符）
- 模型名：例如 `qwen3:30b-a3b-46k`，需与服务端模型一致

连通性校验：登录时会调用 `models.list()` 验证是否可用。


## 运行与调试

```bash
# 开发模式自动重载
uvicorn main:app --reload

# 指定端口
uvicorn main:app --host 0.0.0.0 --port 8000 --reload
```


## 安全与生产建议

- 更换 `main.py` 中的 `SECRET_KEY` 值并转为环境变量管理
- 生产环境使用 HTTPS，并将 Cookie `secure=True`
- 后端设置 IP 访问控制与速率限制（如 Nginx/网关层）
- 为外部 API Key 设置最小权限与定期轮换


## 常见问题（FAQ）

- Q: 登录提示「API 连接失败」？
  - A: 检查 Base URL 与 Key 是否正确，目标服务是否兼容 OpenAI，并确认模型名有效。

- Q: 本地模型怎么配？
  - A: 使用兼容网关（如 Ollama/OpenAI 兼容代理），在登录处填写其 Base URL 与 Key，并选择可用模型名即可。

- Q: 保存后未见到 Markdown 文件？
  - A: 文件写入位置为 `notes/分类/标题.md`，请确认应用进程对该目录有写权限。

- Q: 标签过滤不准？
  - A: 数据库存储为逗号分隔字符串，后端在查询后做了精确匹配过滤；若历史数据格式异常，可手动修正 `tags` 字段或重新保存一次。


## 开发者提示

### 前端开发
- 统一通过 `/api` 前缀访问后端接口
- 修改前端无需构建，刷新页面生效
- 使用 ES6 模块化，支持现代浏览器
- 组件化设计，便于复用和测试
- 响应式设计，支持移动端适配

### 后端开发
- 如需扩展字段，先更新表结构与 `Note/UpdateNoteRequest` 模型，再调整前端渲染
- `__pycache__/` 目录已在 `.gitignore` 中配置忽略，不会提交到版本控制

### 代码结构
- **模块化**：每个 JS 文件负责特定功能
- **组件化**：UI 组件可独立使用和测试
- **可维护性**：清晰的代码结构和注释
- **可扩展性**：易于添加新功能和组件


---

## 问题修复记录

### 2024-12-19 启动错误修复
- **问题**：服务器启动时出现 `FileNotFoundError: [Errno 2] No such file or directory: 'frontend.html'`
- **原因**：`main.py` 第317行引用了不存在的 `frontend.html` 文件
- **解决方案**：将文件引用从 `frontend.html` 修正为 `index.html`
- **状态**：✅ 已修复

### 2024-12-19 禁用模态框拖动功能
- **问题**：用户要求禁用模态框的拖动功能
- **原因**：模态框默认启用拖动功能，用户希望固定位置
- **解决方案**：
  - 修改 `js/components.js` 中 Modal 类的默认配置，将 `draggable` 设为 `false`
  - 修改 `js/app.js` 中模态框初始化，显式设置 `draggable: false`
  - 修改 `styles.css` 中 `.drag-handle` 样式，将 `cursor: move` 改为 `cursor: default`
- **状态**：✅ 已修复

### 2024-12-19 设置默认显示5条笔记
- **问题**：用户希望默认显示5条笔记而不是10条
- **原因**：当前分页配置默认显示10条笔记，用户希望减少到5条
- **解决方案**：
  - 修改 `js/utils.js` 中 `PAGE_SIZE` 常量从 10 改为 5
  - 修改 `js/app.js` 中分页组件的 `pageSize` 配置从 10 改为 5
  - 优化 `renderPage()` 方法，使用动态 `pageSize` 而不是硬编码值
- **状态**：✅ 已修复

### 2024-12-19 AI优化重写功能优化
- **问题**：用户希望AI优化重写默认只提取内容前500个字符用于分析，不修改笔记本身内容
- **原因**：当前AI优化重写会分析全部内容（最多8000字符），用户希望限制分析范围并保护原文
- **解决方案**：
  - 修改 `main.py` 中 `extract_category_and_tags` 函数，将分析内容限制为前500字符
  - 修改 `main.py` 中 `optimize_text` 函数的两个模式，都只使用前500字符进行分析
  - 保持默认模式（analyze）不修改原文内容，只提取标题、分类、标签
  - 更新 README.md 文档，详细说明AI优化重写功能的两种模式
- **状态**：✅ 已修复

### 2024-12-19 模型选择下拉框功能
- **问题**：用户希望默认模型可以通过下拉选择，包括 Qwen3-Next-80B-A3B-Instruct、qwen3:30b-40k 等选项
- **原因**：当前模型输入为文本框，用户希望提供预设模型选项和自定义模型功能
- **解决方案**：
  - 修改 `index.html` 中的模型输入框为下拉选择框，包含常用模型选项
  - 添加自定义模型选项，支持用户输入任意模型名称
  - 修改 `js/app.js` 中的模型处理逻辑，支持下拉选择和自定义输入切换
  - 保持后端API兼容性，无需修改后端代码
- **状态**：✅ 已修复

### 2024-12-19 页面加载时清空AI优化重写提示词
- **问题**：用户希望打开页面时清空所有AI优化重写提示词输入框
- **原因**：页面加载时AI优化重写提示词输入框可能保留之前的值，影响用户体验
- **解决方案**：
  - 在 `js/app.js` 中添加 `clearAIOptimizationPrompts()` 方法
  - 清空新建笔记模态框、预览笔记模态框和全屏模态框中的AI优化重写提示词输入框
  - 在 `loadInitialData()` 方法中调用清空方法，确保页面加载时自动清空
- **状态**：✅ 已修复

### 2024-12-19 自定义AI优化重写提示词支持20000字符分析
- **问题**：用户希望当输入自定义AI优化重写提示词时，能够分析更长的内容（20000个汉字）
- **原因**：默认只分析前4000字符，对于用户主动输入自定义提示词的情况，应该提供更全面的分析
- **解决方案**：
  - 修改 `main.py` 中的 `extract_category_and_tags` 函数，添加 `max_length` 参数
  - 修改 `optimize_text` 函数，检测是否使用自定义提示词（非默认提示词）
  - 当用户输入自定义提示词时，使用20000字符进行分析；否则使用4000字符的默认限制
  - 保持向后兼容性，不影响现有的自动分类功能
- **状态**：✅ 已修复

### 2024-12-19 调整默认分析长度为4000字符
- **问题**：用户希望将默认的分析长度从500字符调整为4000字符
- **原因**：500字符的分析长度可能不够充分，4000字符能提供更准确的分析结果
- **解决方案**：
  - 修改 `extract_category_and_tags` 函数的默认参数从500改为4000
  - 修改 `optimize_text` 函数中的默认长度设置从500改为4000
  - 保持自定义提示词时使用20000字符的逻辑不变
  - 更新相关文档说明
- **状态**：✅ 已修复

### 2024-12-19 AI优化重写功能404错误修复
- **问题**：用户点击笔记编辑优化时出现404错误，错误信息显示"upstream_error"
- **原因**：用户未配置AI API（api_url和api_key为空），系统尝试使用空配置调用AI服务导致404错误
- **解决方案**：
  - 修改 `main.py` 中的 `optimize_text` 函数，添加AI配置检查
  - 当未配置AI API时，返回友好的错误提示："请先配置AI API：在页面顶部填写API地址和密钥，然后点击登录"
  - 修改 `js/api.js` 中的错误处理，特殊处理AI配置相关错误
  - 提供更清晰的用户指导，避免技术性错误信息
- **状态**：✅ 已修复

### 2024-12-19 AI服务连接错误处理优化
- **问题**：用户配置了AI API但仍然出现"upstream_error"错误，错误处理逻辑不完善
- **原因**：AI服务连接失败（404、超时等）时，错误处理没有正确捕获和转换错误信息
- **解决方案**：
  - 修改 `main.py` 中 `get_ai_client` 函数的异常处理，区分不同类型的连接错误
  - 针对404和upstream_error提供"AI服务连接失败，请检查API地址是否正确"的提示
  - 针对超时错误提供"AI服务连接超时，请检查网络连接"的提示
  - 优化 `optimize_text` 函数的错误传递逻辑，确保用户看到友好的错误信息
- **状态**：✅ 已修复

### 2024-12-19 编辑模式AI优化重写提示词优先级修复
- **问题**：在编辑模式下，当用户输入了自定义AI优化重写提示词时，系统仍然优先使用默认提示词
- **原因**：前端代码中使用了 `(this.elements.optPrompt?.value.trim()) || '默认提示词'` 的逻辑，导致即使用户输入了提示词，也会被默认提示词覆盖
- **解决方案**：
  - 修改 `js/app.js` 中的 `handleOptimize` 方法，优先使用用户输入的提示词
  - 修改 `handleFullscreenOptimize` 方法，确保全屏模式也遵循相同的优先级
  - 修改 `handleNewOptimize` 方法，确保新建笔记功能也遵循相同的优先级
  - 使用更清晰的变量命名和注释，提高代码可读性
- **影响范围**：编辑模式、全屏模式、新建笔记模式的AI优化重写功能
- **状态**：✅ 已修复

### 2024-12-19 按钮防重复点击功能
- **问题**：用户可能快速点击按钮导致重复提交请求，影响用户体验和系统稳定性
- **原因**：所有按钮都没有防重复点击保护机制，用户可能在操作执行期间多次点击
- **解决方案**：
  - 在 `js/utils.js` 中添加 `preventDoubleClick` 和 `addPreventDoubleClick` 工具函数
  - 为所有按钮添加防重复点击保护，包括：
    - 主界面按钮：新建笔记、退出登录、清除过滤
    - 模态框按钮：保存、取消、AI优化重写、删除等
    - 分页按钮：上一页、下一页、页码按钮
    - 词云按钮：分类和标签过滤按钮
  - 不同操作设置不同的防重复时间：
    - 快速操作（切换、关闭）：300ms
    - 一般操作（保存、删除）：2000ms
    - AI操作（优化）：3000ms
  - 提供视觉反馈：按钮禁用状态、加载文本提示
- **技术特点**：
  - 支持异步操作（Promise）的防重复处理
  - 自动恢复按钮状态和文本
  - 错误处理和用户友好的提示信息
  - 可配置的延迟时间和加载文本
- **状态**：✅ 已修复

### 2024-12-19 Tailwind CSS CDN 警告修复
- **问题**：项目使用 Tailwind CSS CDN 版本，在生产环境中显示警告："cdn.tailwindcss.com should not be used in production"
- **原因**：Tailwind CSS 官方建议不要在生产环境使用 CDN 版本，应该使用本地构建版本
- **解决方案**：
  - 创建 `tailwind.config.js` 配置文件，指定内容扫描路径
  - 创建 `package.json` 文件，管理 Node.js 依赖
  - 创建 `src/input.css` 源文件，包含所有自定义样式和 Tailwind 指令
  - 将原有的 `styles.css` 中的自定义样式迁移到 Tailwind 组件类中
  - 修改 `index.html`，移除 CDN 引用
  - 创建构建脚本：`build-css.bat`、`build-css.sh`、`setup.bat`、`setup.sh`
  - 更新 README.md，添加 Tailwind CSS 构建说明
- **技术特点**：
  - 使用 Tailwind CLI 构建本地版本
  - 支持开发模式（监听文件变化）和生产模式（压缩输出）
  - 保持所有原有样式和功能不变
  - 提供一键安装脚本，简化部署流程
- **状态**：✅ 已修复

### 2024-12-19 AI优化重写功能重复点击问题修复
- **问题**：用户点击AI优化重写按钮时会触发两次优化，第二次会覆盖第一次的结果
- **原因**：
  - **前端问题**：`addPreventDoubleClick` 函数存在双重锁定机制冲突，内部有自己的锁定机制，但又调用了 `preventDoubleClick` 函数
  - **前端问题**：事件监听器重复绑定，每次调用都会添加新监听器但没有移除旧的
  - **前端问题**：`setLoadingState` 函数和防重复点击的按钮状态管理存在冲突
  - **后端问题**：`optimize_text` 函数会调用两次AI服务：第一次进行内容优化，第二次调用 `extract_category_and_tags` 提取分类标签
- **解决方案**：
  - **前端修复**：重构 `addPreventDoubleClick` 函数，移除双重锁定机制，统一使用单一锁定逻辑
  - **前端修复**：添加事件监听器清理机制，避免重复绑定
  - **前端修复**：移除AI优化重写函数中的手动 `setLoadingState` 调用，让防重复点击功能统一管理按钮状态
  - **后端修复**：将分类标签提取整合到优化过程中，避免重复调用AI服务
  - **后端优化**：在系统提示词中告知AI优先使用现有分类和标签，提高一致性
- **技术特点**：
  - 统一的防重复点击机制，避免状态冲突
  - 自动的按钮状态管理（禁用、加载文本、样式变化）
  - 支持异步操作的防重复处理
  - 后端单次AI调用完成所有优化任务，提高效率
  - 更好的用户体验和错误处理
- **影响范围**：所有AI优化重写按钮（新建笔记、编辑模式、全屏模式）
- **状态**：✅ 已修复

### 2024-12-19 登录状态验证修复
- **问题**：用户点击AI优化重写时总是提醒"优化失败，是否登录"，即使Cookie中有登录信息
- **原因**：后端的 `/api/config` 接口只检查Cookie是否存在，但没有验证Cookie中的API配置是否有效。当Cookie存在但API配置无效时，后端仍然返回 `logged_in: true`，导致前端认为已登录，但实际调用AI优化重写时会失败
- **解决方案**：
  - 修改后端的 `/api/config` 接口，添加API配置有效性验证
  - 只有当API配置真正有效时才返回 `logged_in: true`
  - 当API配置无效时，返回 `logged_in: false` 但保留配置信息供用户查看
- **技术特点**：
  - 真实的登录状态验证，避免Cookie存在但功能不可用的混淆情况
  - 提供更准确的用户反馈，明确区分"未登录"和"配置无效"状态
  - 保持向后兼容性，不影响现有的登录流程
- **影响范围**：所有依赖登录状态的功能（AI优化重写、自动分类等）
- **状态**：✅ 已修复

### 2024-12-19 AI优化重写提示词混合问题修复
- **问题**：当用户输入了自定义AI优化重写提示词时，系统仍然混合了默认的系统提示词，导致用户意图被干扰
- **原因**：在自定义提示词模式下，代码仍然在system message中包含了固定的系统提示词，然后在user message中又添加了用户的提示词，造成混合
- **解决方案**：
  - 修改 `main.py` 中的 `optimize_text` 函数，当用户提供自定义提示词时，直接使用用户提示词
  - 移除system message中的固定提示词，将用户提示词作为主要指令
  - 保留必要的JSON格式要求和现有分类标签信息，确保输出格式正确
- **技术特点**：
  - 完全尊重用户的自定义提示词，不进行任何混合或修改
  - 保持输出格式的一致性，确保前端能正确解析结果
  - 提供更纯净的AI优化重写体验，让用户完全控制优化方向
- **影响范围**：所有使用自定义提示词的AI优化重写功能
- **状态**：✅ 已修复

### 2024-12-19 全屏显示图标消失问题修复
- **问题**：用户点击全屏按钮进入全屏模式后，关闭全屏模式回到普通预览时，全屏显示图标消失了
- **原因**：`closeFullscreenModal` 方法在关闭全屏模态框时，没有确保普通模态框（`viewNoteModal`）保持打开状态，导致模态框状态管理混乱
- **解决方案**：
  - 修改 `js/app.js` 中的 `closeFullscreenModal` 方法
  - 在关闭全屏模态框时，显式设置普通模态框的 `isOpen` 状态为 `true`
  - 确保全屏按钮在关闭全屏模式后仍然可见和可用
- **技术特点**：
  - 修复模态框状态管理问题，确保状态一致性
  - 保持用户界面功能的完整性
  - 提供流畅的全屏模式切换体验
- **影响范围**：全屏显示功能
- **状态**：✅ 已修复

### 2024-12-19 自动完成功能初始化失败修复
- **问题**：自动完成功能初始化时出现 `TypeError: Failed to set an indexed property [0] on 'CSSStyleDeclaration': Indexed property setter is not supported.` 错误
- **原因**：`dom.js` 中的 `createElement` 函数使用 `Object.assign(element.style, options.style)` 时，`options.style` 是字符串格式（如 `'display: none;'`），但 `Object.assign` 期望的是对象格式，导致浏览器报错
- **解决方案**：
  - 修改 `frontend/js/utils/dom.js` 中的 `createElement` 函数
  - 添加样式属性类型检查，支持字符串和对象两种格式
  - 当 `style` 为字符串时，使用 `setAttribute` 方法设置
  - 当 `style` 为对象时，使用 `Object.assign` 方法设置
- **技术特点**：
  - 向后兼容，支持原有的字符串样式格式
  - 同时支持对象格式的样式设置，提供更好的灵活性
  - 修复了自动完成组件的初始化问题
- **影响范围**：所有使用 `createElement` 函数创建带样式的元素的功能
- **状态**：✅ 已修复

### 2024-12-19 分类标签自动完成数据源修复
- **问题**：分类和标签的自动完成功能不能自动提示已经存在的数据，无法调用后端接口获取分类和标签列表
- **原因**：前端代码试图从页面上的词云元素中获取分类和标签数据，这种方式不可靠且数据可能不完整
- **解决方案**：
  - 修改 `frontend/js/core/app.js` 中的 `initAutocomplete` 方法，改为异步方法
  - 直接调用后端API接口 `getCategories()` 和 `getTags()` 获取完整的分类和标签数据
  - 添加错误处理和备用方案，当API调用失败时仍能从统计数据获取数据
  - 确保自动完成组件使用完整准确的数据源
- **技术特点**：
  - 使用后端API作为主要数据源，确保数据的完整性和准确性
  - 提供备用方案，提高系统的健壮性
  - 异步数据加载，避免阻塞页面初始化
  - 详细的日志输出，便于调试和监控
- **影响范围**：所有自动完成功能（新建笔记、编辑笔记的分类和标签输入）
- **状态**：✅ 已修复

### 2024-12-19 自动完成显示逻辑修复
- **问题**：自动完成功能逻辑正常，但建议列表无法显示，界面看不见提示内容
- **原因**：`showElement()` 函数只是移除了 `hidden` 类，但容器还有内联的 `style="display: none;"`，内联样式优先级比CSS类高，导致元素仍然被隐藏
- **解决方案**：
  - 修改 `frontend/js/utils/dom.js` 中的 `showElement` 和 `hideElement` 函数
  - `showElement` 函数同时移除 `hidden` 类和设置 `style.display = ''`
  - `hideElement` 函数同时添加 `hidden` 类和设置 `style.display = 'none'`
  - 确保显示/隐藏逻辑的一致性和可靠性
- **技术特点**：
  - 同时处理CSS类和内联样式，避免样式冲突
  - 统一的显示/隐藏逻辑，提高代码可维护性
  - 修复了整个应用中所有使用显示/隐藏功能的地方
- **影响范围**：所有使用 `showElement` 和 `hideElement` 的UI组件
- **状态**：✅ 已修复

### 2024-12-19 标签自动完成行为优化
- **问题**：用户希望标签自动完成默认显示全部标签，选择后自动追加到输入框，而不是替换现有内容
- **原因**：原有的标签自动完成需要输入才能显示建议，且选择标签会替换输入框内容
- **解决方案**：
  - 修改 `createTagAutocomplete` 函数的 `minLength` 从 1 改为 0
  - 修改 `handleInput` 方法，当 `minLength` 为 0 且无输入时显示所有标签
  - 添加焦点事件处理，标签输入框获得焦点时自动显示所有标签
  - 保持现有的标签追加逻辑，选择标签后自动追加到现有内容后面
  - 更新占位符文本为"输入标签名称或点击选择..."
- **技术特点**：
  - 智能的显示逻辑，根据 `minLength` 配置决定是否显示全部选项
  - 用户友好的交互体验，点击输入框即可看到所有可用标签
  - 保持分类自动完成的原有行为（需要输入才显示）
  - 标签追加逻辑避免重复添加相同标签
- **影响范围**：标签自动完成功能（新建笔记、编辑笔记的标签输入）
- **状态**：✅ 已修复

### 2024-12-19 预览模式无法切换到编辑模式修复
- **问题**：用户反映预览模式无法切换到编辑模式，点击切换按钮没有反应
- **原因**：HTML中有预览/编辑模式切换按钮，但JavaScript代码中没有绑定这些按钮的事件处理器，导致点击按钮无效果
- **解决方案**：
  - 在 `bindViewNoteModalEvents()` 方法中为预览/编辑切换按钮添加事件监听器
  - 在 `bindFullscreenModalEvents()` 方法中为全屏预览/编辑切换按钮添加事件监听器
  - 实现 `switchToEditMode()` 和 `switchToPreviewMode()` 方法处理普通模态框的模式切换
  - 实现 `switchToFullscreenEditMode()` 和 `switchToFullscreenPreviewMode()` 方法处理全屏模态框的模式切换
  - 实现 `resetToPreviewMode()` 和 `resetFullscreenToPreviewMode()` 方法重置模态框为预览模式
  - 实现 `syncDataToFullscreen()` 方法同步数据到全屏模态框
  - 修改 `showNoteInModal()` 方法，确保打开笔记时默认显示预览模式
  - 修改 `handleFullscreen()` 方法，确保打开全屏时同步数据并重置为预览模式
  - 修改HTML，确保全屏编辑器默认隐藏
- **技术特点**：
  - 完整的预览/编辑模式切换功能，支持普通模态框和全屏模态框
  - 自动数据同步，确保编辑内容在模式切换时不会丢失
  - 防重复点击保护，提供流畅的用户体验
  - 状态管理完善，按钮状态和显示内容保持一致
- **影响范围**：笔记预览功能、全屏显示功能
- **状态**：✅ 已修复

### 2024-12-21 AI优化重写功能404错误修复
- **问题**：用户反映AI优化重写功能返回404错误，提示"upstream_error"
- **原因**：
  1. 后端在依赖注入中硬编码了模型名称"qwen3:30b-40k"，可能导致模型不存在
  2. AI服务初始化时会调用client.models.list()测试连接，可能返回404错误
  3. 登录API没有将模型名称保存到Cookie中，导致后续请求使用默认模型
  4. 错误处理机制不够完善，没有正确区分不同类型的错误
- **解决方案**：
  1. 修复AI服务初始化逻辑，移除可能导致404错误的连接测试
  2. 改进错误处理机制，添加更详细的错误信息提示
  3. 修复模型名称传递问题，支持自定义模型名称
  4. 更新登录API，将模型名称保存到Cookie中
  5. 改进前端错误处理，提供更友好的错误提示
- **技术特点**：
  - 支持动态模型名称配置，不再硬编码模型名称
  - 完善的错误分类和处理机制
  - 更好的用户提示信息
  - 向后兼容的Cookie格式
- **影响范围**：AI优化重写功能、用户登录功能
- **状态**：✅ 已修复

### 2024-12-21 AI优化重写状态管理改进
- **问题**：用户反映AI优化重写功能出现"AI优化重写正在进行中，请稍候..."的错误，导致无法进行新的优化
- **原因**：
  1. AI服务的`isOptimizing`状态可能在某些异常情况下没有正确重置
  2. 多个优化请求可能同时触发，导致状态管理混乱
  3. 缺乏有效的状态重置机制
- **解决方案**：
  1. 改进AI服务的状态管理，使用Promise缓存避免重复请求
  2. 添加详细的调试日志，便于问题排查
  3. 实现自动状态重置机制，在检测到异常时自动恢复
  4. 添加全局调试函数，支持手动重置状态
  5. 改进错误处理，提供更友好的用户提示
- **技术特点**：
  - 智能请求去重，避免重复的AI API调用
  - 完善的状态管理和错误恢复机制
  - 丰富的调试信息和工具
  - 向后兼容的API设计
- **影响范围**：AI优化重写功能、用户体验
- **状态**：✅ 已修复

### 2024-12-21 重复请求AbortError修复
- **问题**：用户快速点击AI优化重写按钮时出现"AbortError: signal is aborted without reason"错误
- **原因**：
  1. 用户快速点击导致多个请求同时发起
  2. API层面的AbortController机制与AI服务的请求去重机制冲突
  3. 防重复点击的延迟时间不够长
  4. 缺乏API请求级别的去重机制
- **解决方案**：
  1. 实现API请求缓存机制，避免重复的HTTP请求
  2. 改进AbortError的错误处理，不显示用户友好的错误信息
  3. 增加AI优化重写按钮的防重复点击延迟时间（3秒→5秒）
  4. 添加请求缓存管理工具和调试函数
  5. 完善错误分类和处理逻辑
- **技术特点**：
  - 多层请求去重：按钮级别 + AI服务级别 + API级别
  - 智能错误处理：区分正常去重和真实错误
  - 完善的调试工具：支持缓存状态查询和清理
  - 更好的用户体验：减少不必要的错误提示
- **影响范围**：AI优化重写功能、API请求管理、用户体验
- **状态**：✅ 已修复

### 2024-12-21 AI优化重写提示词行为优化
- **问题**：用户希望当输入自定义AI优化重写提示词时，只更新文本内容，不调整标题、分类、标签等元数据
- **原因**：当前AI优化重写功能无论是否使用自定义提示词，都会更新所有字段（标题、分类、标签、内容），用户希望自定义提示词时只专注于内容优化
- **解决方案**：
  1. 修改前端AI优化重写处理逻辑，根据是否使用自定义提示词决定更新哪些字段
  2. 自定义提示词模式：只更新文本内容，保持标题、分类、标签不变
  3. 默认提示词模式：保持现有逻辑，更新所有字段（标题、分类、标签、内容）
  4. 支持所有AI优化重写场景：新建笔记、编辑笔记、全屏模式
- **技术特点**：
  - 智能字段更新：根据提示词类型决定更新范围
  - 保持向后兼容：默认提示词行为完全不变
  - 全场景支持：新建、编辑、全屏模式都支持新逻辑
  - 用户体验优化：自定义提示词时专注于内容优化
- **影响范围**：所有AI优化重写功能（新建笔记、编辑笔记、全屏模式）
- **状态**：✅ 已修复

### 2024-12-21 AI优化重写按钮视觉效果优化
- **问题**：用户希望AI优化重写按钮的点击效果更明显，包括文字提示、超时时间、按钮状态等
- **原因**：当前AI优化重写按钮的视觉效果不够明显，用户无法清楚了解操作状态
- **解决方案**：
  1. 修改按钮文字为"AI优化重写"，统一所有AI优化重写按钮的显示文本
  2. 加长超时时间：新建笔记从5秒增加到8秒，编辑和全屏模式从3秒增加到8秒
  3. 改进按钮禁用/启用逻辑：点击后立即禁用按钮，显示"AI优化重写中..."文字
  4. 增强视觉效果：添加渐变动画、缩放效果、透明度变化
  5. 完善状态恢复：操作完成后自动恢复按钮原始状态和样式
- **技术特点**：
  - 渐变动画效果：使用CSS keyframes实现流动的渐变背景
  - 按钮状态管理：禁用、文字变化、样式变化、自动恢复
  - 视觉反馈：缩放、透明度、光标状态变化
  - 统一体验：所有AI优化重写按钮使用相同的视觉效果
- **影响范围**：所有AI优化重写按钮（新建笔记、编辑笔记、全屏模式）
- **状态**：✅ 已修复

### 2024-12-21 AI优化重写按钮状态恢复修复
- **问题**：用户反映AI优化重写完成后按钮消失，无法继续使用
- **原因**：在恢复按钮状态时，清空了背景样式但没有正确恢复原始样式，导致按钮不可见
- **解决方案**：
  1. 保存按钮的原始样式属性（背景色、文字颜色等）
  2. 在恢复时正确设置原始背景色而不是清空
  3. 重置所有可能影响显示的样式属性
  4. 确保按钮的显示状态（display、visibility等）正确恢复
- **技术特点**：
  - 完整的样式状态保存和恢复机制
  - 确保按钮在所有情况下都能正确显示
  - 保持原有的视觉效果和交互体验
- **影响范围**：所有AI优化重写按钮的状态恢复
- **状态**：✅ 已修复

### 2024-12-21 AI优化重写按钮影响其他按钮问题修复
- **问题**：用户反映所有按钮都变成"AI优化重写中"，影响了其他按钮的正常使用，且恢复时间太长
- **原因**：
  1. 防重复点击函数对所有按钮都应用了AI优化重写的特殊效果
  2. 超时时间设置为8秒太长，影响用户体验
- **解决方案**：
  1. 创建专用的AI优化重写按钮防重复点击函数 `preventDoubleClickAI`
  2. 普通按钮使用简单的 `preventDoubleClick` 函数，不改变按钮外观
  3. 只有AI优化重写按钮使用特殊的视觉效果和动画
  4. 将AI优化重写按钮的超时时间从8秒减少到3秒
- **技术特点**：
  - 分离关注点：普通按钮和AI优化重写按钮使用不同的处理逻辑
  - 快速恢复：AI优化重写按钮3秒后恢复，其他按钮1-2秒恢复
  - 精确控制：只有AI优化重写按钮会显示特殊效果
  - 保持兼容：不影响现有按钮的正常功能
- **影响范围**：所有按钮的防重复点击行为
- **状态**：✅ 已修复

### 2024-12-21 AI优化重写按钮即时恢复优化
- **问题**：用户反映AI优化重写功能正常，内容已经填充，但按钮恢复正常很慢
- **原因**：按钮状态恢复使用固定的超时时间，即使AI处理完成也要等待固定时间才恢复
- **解决方案**：
  1. 修改按钮状态恢复逻辑，在AI处理完成后立即恢复按钮状态
  2. 移除固定的超时等待，改为在try/catch块中直接恢复
  3. 将超时时间从3秒减少到1秒，主要用于防重复点击
  4. 确保无论成功还是失败都能正确恢复按钮状态
- **技术特点**：
  - 即时恢复：AI处理完成后立即恢复按钮，无需等待
  - 错误处理：无论成功还是失败都确保按钮状态正确恢复
  - 快速响应：超时时间减少到1秒，主要用于防重复点击
  - 用户体验：按钮状态与AI处理进度同步
- **影响范围**：所有AI优化重写按钮的状态恢复时机
- **状态**：✅ 已修复

### 2024-12-21 删除笔记重复提示修复
- **问题**：用户反映删除笔记时会提示2次确认对话框
- **原因**：
  1. 删除按钮的事件监听器被绑定了两次
  2. `bindViewNoteModalEvents()`和`bindFullscreenModalEvents()`方法被重复调用
  3. `init()`方法中既调用了`bindModalEvents()`又单独调用了各个绑定方法
  4. 导致删除确认对话框被触发两次
- **解决方案**：
  1. 移除重复的事件绑定调用
  2. 为不同模态框的删除按钮创建独立的处理方法
  3. 保持代码结构清晰，避免重复绑定
  4. 确保每个事件监听器只被绑定一次
- **技术特点**：
  - 清晰的事件绑定结构
  - 避免重复的事件监听器
  - 独立的删除处理方法
  - 更好的代码组织
- **影响范围**：删除笔记功能、用户体验
- **状态**：✅ 已修复

### 2024-12-21 新建笔记时清空历史输入内容
- **问题**：用户希望新建笔记时清空所有历史输入内容，避免之前的内容影响新笔记
- **原因**：新建笔记模态框会保留之前输入的内容，用户需要手动清空，影响用户体验
- **解决方案**：
  1. 在App类中添加`clearNewNoteInputs()`方法，清空新建笔记模态框中的所有输入字段
  2. 在App类中添加`clearAIOptimizationPrompts()`方法，清空所有AI优化重写提示词输入框
  3. 修改`handleNewNote()`方法，在显示模态框前先清空所有输入内容
  4. 在`loadInitialData()`方法中调用清空AI优化重写提示词方法，确保页面加载时清空
- **技术特点**：
  - 清空所有输入字段：标题、内容、分类、标签、AI优化重写提示词
  - 清空预览内容并隐藏预览区域
  - 页面加载时自动清空所有AI优化重写提示词
  - 提供更好的用户体验，避免历史内容干扰
- **影响范围**：新建笔记功能、用户体验
- **状态**：✅ 已修复

### 2024-12-21 模型底部显示当前配置信息
- **问题**：用户希望在主界面底部显示当前配置的API地址和选择的模型信息
- **原因**：用户需要清楚了解当前使用的AI配置，便于管理和调试
- **解决方案**：
  1. 在主界面底部添加配置信息显示区域，包含API地址和模型名称
  2. 修改后端配置接口，正确解析Cookie中的模型信息
  3. 修改前端代码，在登录成功后获取并显示配置信息
  4. 添加美观的样式和动画效果，包括连接状态指示器
- **技术特点**：
  - 实时显示当前API配置：地址和模型名称
  - 连接状态指示器：绿色圆点表示已连接
  - 响应式设计：移动端和桌面端都有良好显示效果
  - 动画效果：淡入动画和悬停效果
  - 自动隐藏：未登录时自动隐藏配置信息
- **影响范围**：主界面显示、用户体验、配置管理
- **状态**：✅ 已实现

### 2024-12-21 删除无用的配置提示信息
- **问题**：页面中存在"请先配置 OpenAI API 地址和 Key"的提示信息，但实际不需要显示
- **原因**：这个提示信息是多余的，因为用户已经通过API配置区域进行配置
- **解决方案**：
  1. 删除HTML中的`noConfig`提示区域
  2. 清理相关的无用代码和元素
- **技术特点**：
  - 简化页面结构，减少不必要的元素
  - 提供更清洁的用户界面
  - 避免用户混淆
- **影响范围**：主界面显示、用户体验
- **状态**：✅ 已删除

### 2024-12-21 配置信息显示位置优化
- **问题**：用户希望将配置信息显示区域放在header最下面，让它更美观
- **原因**：原来的位置在主界面底部，不够显眼且影响整体布局美观
- **解决方案**：
  1. 将配置信息显示区域移动到header下面
  2. 优化样式设计，使用渐变背景和现代化UI元素
  3. 添加图标和更好的视觉层次
  4. 改进响应式设计，适配移动端显示
- **技术特点**：
  - 位置优化：放在header下面，更显眼且美观
  - 现代化设计：渐变背景、圆角边框、阴影效果
  - 图标增强：🌐 API地址、🤖 模型标识
  - 动画效果：淡入动画、悬停效果、脉冲指示器
  - 响应式布局：桌面端横向排列，移动端纵向排列
- **影响范围**：界面布局、用户体验、视觉效果
- **状态**：✅ 已优化

### 2024-12-21 配置信息显示简化设计
- **问题**：用户希望配置信息显示更加简洁，去掉边框和图标等装饰元素
- **原因**：之前的设计过于复杂，用户偏好简洁清爽的界面
- **解决方案**：
  1. 移除渐变背景、边框、阴影等装饰效果
  2. 删除图标元素（🌐、🤖等）
  3. 简化样式，只保留基本的文本显示
  4. 保留连接状态指示器和淡入动画
- **技术特点**：
  - 极简设计：纯文本显示，无边框无背景
  - 保留功能性：连接状态指示器和动画效果
  - 清晰布局：水平排列，间距适中
  - 响应式：移动端自动调整为垂直布局
- **影响范围**：界面设计、视觉效果
- **状态**：✅ 已简化

### 2024-12-21 标题文案优化
- **问题**：用户希望优化页面标题和描述文案，让表达更加简洁有力
- **原因**：原有文案过长，信息冗余，不够简洁明了
- **解决方案**：
  1. 保持标题不变："🧠 智能笔记管理"
  2. 优化描述文案：从"AI 自动分类，自动优化，一键存储，全文搜索，支持本地部署AI模型"
  3. 简化为："AI 驱动的智能笔记系统，自动分类优化，本地化部署"
- **技术特点**：
  - 更简洁：从20个字减少到18个字
  - 更专业：使用"AI 驱动"、"系统"等专业术语
  - 更聚焦：突出核心功能（分类优化、本地部署）
  - 更易读：去除冗余信息，保留关键特性
- **影响范围**：页面标题、用户体验、品牌形象
- **状态**：✅ 已优化

### 2024-12-21 全屏模式保存后不会关闭修复
- **问题**：用户反映全屏模式保存后不会关闭，影响用户体验
- **原因**：`handleFullscreenSave` 方法只是一个空的占位符，没有实现实际的保存逻辑
- **解决方案**：
  1. 实现完整的全屏保存功能，收集全屏模态框中的所有数据（标题、内容、分类、标签）
  2. 调用后端API保存笔记数据
  3. 保存成功后自动关闭全屏模态框和普通模态框
  4. 同步数据从全屏模态框到普通模态框，确保数据一致性
  5. 重新加载笔记列表和统计数据
- **技术特点**：
  - 完整的数据收集和验证逻辑
  - 统一的错误处理和用户提示
  - 数据双向同步，确保普通模态框和全屏模态框数据一致
  - 保存后自动关闭所有相关模态框，提供流畅的用户体验
- **影响范围**：全屏模式保存功能、用户体验
- **状态**：✅ 已修复

### 2024-12-21 全屏模式保存后关闭所有模态框优化
- **问题**：用户反映全屏模式保存后还需要手动关闭普通模态框，希望保存后直接关闭所有相关模态框
- **原因**：之前的实现只关闭了全屏模态框，没有同时关闭普通模态框
- **解决方案**：
  1. 修改 `handleFullscreenSave` 方法，保存成功后同时关闭全屏模态框和普通模态框
  2. 确保与其他保存方法的行为保持一致
  3. 提供更好的用户体验，无需用户手动关闭多个模态框
- **技术特点**：
  - 统一的模态框关闭逻辑，与其他保存方法保持一致
  - 保存后自动关闭所有相关模态框，无需用户手动操作
  - 保持数据同步和重新加载功能不变
- **影响范围**：全屏模式保存功能、用户体验
- **状态**：✅ 已优化

### 2024-12-21 分析标题分类按钮功能添加
- **问题**：用户希望在添加和编辑功能中添加一个单独的"分析标题分类"按钮，功能等同于用户没有输入提示词的效果
- **原因**：用户需要一个快速的分析功能，不需要手动清空提示词输入框
- **解决方案**：
  1. 在新建笔记模态框中添加"分析标题分类"按钮，位于"AI优化重写"按钮之前
  2. 在编辑笔记模态框中添加"分析标题分类"按钮，位于"AI优化重写"按钮之前
  3. 在全屏模态框中添加"分析标题分类"按钮，位于"AI优化重写"按钮之前
  4. 实现分析标题分类功能逻辑，等同于无提示词的AI优化重写（使用默认提示词）
  5. 为分析标题分类按钮添加独特的绿色渐变样式和动画效果
- **技术特点**：
  - 分析标题分类功能使用默认提示词，自动提取标题、分类、标签并优化内容
  - 支持所有模态框场景：新建笔记、编辑笔记、全屏模式
  - 绿色渐变按钮样式，与AI优化重写按钮（紫色）形成视觉区分
  - 完整的防重复点击保护和错误处理机制
  - 与现有AI优化重写功能完全兼容，不影响原有功能
- **影响范围**：所有笔记编辑功能、用户体验、界面设计
- **状态**：✅ 已实现

---

如需我继续完善自动化测试、Dockerfile、或提供一键本地模型（Ollama）对接脚本，请告诉我。


